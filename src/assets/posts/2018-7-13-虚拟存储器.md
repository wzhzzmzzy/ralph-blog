---
layout: post
title: 操作系统笔记（三）：虚拟存储器
author: wzhzzmzzy
date: 2018-7-13
categories: Tech
tags: 
    - Linux
    - 操作系统
description: 讲真，这一段我并没有特别理解，不过系统 I/O 方面还是了解了很多东西。示例中有一个 RIO 包，没有做很详细的笔记，但是通过阅读源码就能理解，非常简单。
---

## 虚拟存储器

为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟存储器。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 
2. 它为每个进程提供了一致的地址空间，从而简化了存储器管理。
3. 它保护了每 个进程的地址空间不被其他进程破坏。

### 虚拟存储器作为缓存的工具

虚拟存储器被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上数组的内容被缓存在主存中。 虚拟存储器被分为一定大小的块，这些块称为虚拟页，类似的，物理存储器被分割为物理页。

可以将主存看作磁盘的缓存，那么虚拟存储就能在主存上获得缓存。

#### DRAM 缓存的组织结构

SRAM 缓存指的是 CPU 和主存之间的高速缓存，DRAM 缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。

由于 DRAM 缓存未命中时有着巨大的不命中开销，所以DRAM 缓存时全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。

#### 页表

虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中 的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。 

页表提供了虚拟页到物理页到映射。

#### 缺页

DRAM 缓存不命中称为缺页。缺页异常调用内核中的缺页异常处理程序，选择一个牺牲页。磁盘和存储器之间传送页到活动叫做**交换**或者**页面调度**。在正常使用时，主存会一直等待，直到有不命中发生时，才会换入页面，这种策略称为按需页面调度。

#### 局部性

局部性是程序十分重要的一个特性，尽管在整个运行过程中，程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面集合上工作，这个集合叫做工作集。

只要我们的程序有好的时间局部性，虚拟存储器系统就能工作得相当好。

### 虚拟存储器作为存储器管理的工具

虚拟存储器简化了存储器管理，并提供了一种自然的保护存储器的方法。

操作系统为每个进程提供一个独立的页表，因而也就是一个独立的虚拟地址空间。

- 独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。 
- 虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。 
- 虚拟存储器简化了向用户进程提供一个简单的分配额外存储器的工作。
- 独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。

### 地址翻译

形式上来说，地址翻译是一个 N 元素的虚拟地址空间中的元素和一个 M 元素的物理地址空间中元素之间的映射。 

页面命中时，CPU 执行如下步骤：

1. 处理器生成虚拟地址，传给 MMU；
2. MMU 生成 PTE 地址，从缓存请求得到它；
3. 缓存向 MMU 返回 PTE；
4. MMU 构造物理地址，传送给缓存；
5. 缓存返回请求的数据字给处理器。

页面命中完全由硬件处理，缺页则要求硬件和系统内核协作完成。

1. 处理器生成虚拟地址，传给 MMU；
2. MMU 生成 PTE 地址，从缓存请求得到它；
3. 缓存向 MMU 返回 PTE；
4. PTE 中的有效位数零，所以 MMU 触发了一次异常，传递 CPU 中的控制到系统内核中的缺页异常处理程序。
5. 缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，就把它换出磁盘。

#### 利用 TLB 加速地址翻译

正如我们看到的，每次 CPU 产生一个虚拟地址， MMU 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这又会要求从存储器取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 缓存中，那么开销就下降到 1 个或 2 个周期。

系统在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器。

TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。当 TLB 命中时，MMU 的翻译步骤会变得非常快。

### 存储器映射

Linux (以及其他一些形式的 Unix) 通过将一个虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容，这个过程称为存储器映射。虚拟存储器区域可以映射到两种类型的对象中的一种：

1. Unix 文件系统中的普通文件；
2. 匿名文件:一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。

一个对象可以被映射到虚拟存储器的一个区城，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。

另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。

私有对象有一种特别的机制叫做写时拷贝。两个进程将一个私有对象映射到它们虚拟存储器的不同区域，但是共享这个对象的同一个物理拷贝。对于每个映象私有对象的进程，相应私有区域的页表条目都被标记为只读。并且区域结构被标记为私有的写时拷贝。

#### 再看`fork`函数

既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道`fork`函数是如何创建一个带有自己独立虚拟地址空间的新进程的。

当`fork`函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的`mm_struct`、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。 

当`fork`在新进程中返回时，新进程现在的虚拟存储器刚好和调用`fork`时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。

### 系统级 I/O

所有语言的运行时系统都提供执行 I/O 的较高级别的工具，包含像`printf`和`scanf`这样带缓冲区的 I/O 函数。这些高级 I/O 函数都是由系统级 Unix I/O 函数来实现的。

#### Unix I/O

一个 Unix 文件就是一个 m 个字节的序列。所有的 I/O 设备，比如网络、磁盘、终端，都被模型化为文件。Unix I/O 就是一个统一的应用接口。

一个应用程序通过要求内核打开相应的文件来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做描述符。在后续的文件操作中，描述符用于标识这个文件。

#### 打开和关闭文件

进程通过调用`open`函数来打开一个已存在的文件或者创建一个新文件。

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcnt1.h>

int open(char *filename, int flags, mode_t mode);
```

`open`函数将`filename`转换为一个文件描述符，并且返回描述符数字，`flags`参数指明如何访问这个文件，`mode`参数指定了新文件的访问权限位。

### 读写文件

应用程序是通过分别调用`read`和`write`函数来执行输入和输出的。

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
```

`read`函数从描述符为`fd`的当前文件位置拷贝最多`n`个字节到存储器位置`buf`。返回值`-1`表示一个错误，而返回值`0`表示 EOF。否则，返回值表示的是实际传送的字节数量。

`write`函数从存储器位置`buf`拷贝至多`n`个字节到描述符`fd`的当前文件位置。

### 标准 I/O

ANSI C 定义了一组高级输入输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代。这个库提供了打开和关闭文件的函数 (`fopen`和`fclose`、读和写字节的函数 (`fread`和`fwrite`)、读和写字符串的函数 (`fgets`和`fputs`), 以及复杂的格式化的 I/O 函数 (`scanf`和`printf`)。

标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。

```c
#include <stdio.h>
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
```

### 流和套接字的限制

流的输入输出是有限制的。

1. 跟在输出函数之后的输入函数。如果中间没有插入对`fflush`、`fseek`、`fsetpos`或者`rewind`的调用，一个输入函数不能跟随在一个输出函数之后。`fflush`函数清空与流相关的缓冲区。后三个函数使用 Unix I/O`lseek`函数来重置当前的文件位置。
2. 跟在输入函数之后的输出函数。如果中间没有插入对`fseek`、`fsetpos`或者`rewind`的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 EOF。

这些限制同样适用于套接字，但是对套接字使用`lseek`是非法的。对流的第一个限制能够采用刷新缓冲区来满足，第二个限制只能通过对同一个套接字打开两个流来满足。

```c
FILE *fpin, *fpout;

fpin = fdopen(sockfd, "r");
fpout = fdopen(sockfd, "w");
```

这里就有些麻烦，两个流都需要被关闭，而且关闭时都会试图关闭同一个套接字描述符，所以第二个操作就会失败。因此，在网络套接字上，不应该使用标准 I/O 来输入输出。
