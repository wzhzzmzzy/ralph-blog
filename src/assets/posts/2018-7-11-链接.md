---
layout: post
title: 操作系统笔记（一）：链接
author: wzhzzmzzy
date: 2018-7-11
categories: Tech
tags: 
    - Linux
    - 操作系统
description: 算是真正系统地了解操作系统的一次阅读。做了很不少的笔记，不过其实还不是很全。对于链接和编译，之后会更深入地去了解 GNU 的编译过程。
---

## 链接

链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程 。链接可以执行于编译时、加载时，甚至运行时。

链接器十分关键，它使得分离编译成为可能。我们不需要组织一个巨大的源文件，而可以将其分解为更小、更好管理的模块。

### 编译器驱动程序

举一个非常简单的例子：

```c
// main.c
#include <stdio.h>

void swap();

int buf[2] = {1, 2};

int main() {
    printf("%d %d\n", buf[0], buf[1]);
    swap();
    printf("%d %d\n", buf[0], buf[1]);
    return 0;
}

// swap.c
extern int buf[];

int *bufp0 = &buf[0];
int *bufp1;

void swap() {
    int temp;

    bufp1 = &buf[1];
    temp = *bufp0;
    *bufp0 = *bufp1;
    *bufp1 = temp;
}
```

这是一个两个源文件组成的实例程序。使用下面的命令可以初始化这个程序：

```shell
$ gcc -O2 -g -o p main.c swap.c
```

首先，编译系统运行 C 预处理器。它将 C 源程序`main.c`翻译成 ASCII 码中间文件`main.i`，然后运行 C 编译器，将`main.i`翻译成 ASCII 汇编语言文件`main.s`，然后运行汇编器，将`main.s`翻译成一个可重定位目标文件`main.o`。

驱动程序经过相同的过程生成`swap.o`，然后运行链接器，将多个源文件组合起来，创建一个可执行目标文件。

### 静态链接

上面 GCC 所使用的链接器 Unix ld 称为静态链接器，以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。

要构造可执行文件，链接器需要完成两个主要任务：

- 符号解析：将每个符号引用和一个符号定义联系起来。
- 重定位：将数据节和代码重定位。

### 目标文件

目标文件有三种形式：

- 可重定位目标文件：包含二进制代码和数据，可以合并，创建可执行目标文件。
- 可执行目标文件：包含二进制代码和数据，可以直接被拷贝到存储器并执行。
- 共享目标文件：一种特殊类型的可重定位目标文件，可以动态地被加载到存储器并链接。

### 可重定位目标文件

Unix 系统中使用 ELF 格式。ELF 头以一个 16 字节的序列开始，描述生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。ELF 文件的末尾是节头部表。头和节头部表之间的都是节，包含：

- `.text`：机器代码；

- `.rodata`：只读数据；
- `.data`：已经初始化的全局 C 变量；
- `.bss`：未初始化的全局 C 变量；
- `.symtab`：一个符号表，记录定义和引用的函数和全局变量信息；
- `.rel.text`：描述`.text`节中位置的列表，当链接器把这个目标文件和其他文件结合时， 需要修改这些位置。 
- `.debug`：调试符号表，包含程序中定义的局部变量和类型定义；
- `.line`：行号和`.text`机器指令之间的映射，使用`-g`选项时才会得到这张表。
- `.strtab`：字符串表，其内容包括`.syrntab`和`.debug`节中的符号表。

### 符号和符号表

每个可重定位目标模块都有一个符号表，包含其定义和引用的符号信息。在链接器上下文中，有两不同的符号：由模块定义，能被其他模块引用的全局符号、在本模块中的本地符号。本地符号指的是静态（static）属性。

对于模块而言，静态属性类似于面向对象中的私有属性，也就是说，得到了静态声明的属性不可以在模块外部被引用。

### 可执行目标文件

可执行目标文件和可重定位目标文件相似，还包括程序入口点，也就是当程序运行时要执行的第一条指令的地址。`.text`、`.rodata`和`.data`和可重定位目标文件中的节是相似的，除了这些节已经被定位到它们最终运行的存储器地址以外。

可执行文件被设计得很容易加载到存储器。要运行可执行目标文件`p`，可以在 Unix Shell 的命令行中输入它的位置：

```shell
$ ./p
```

Shell 会认为`p`是一个可执行目标文件，通过调用某个主流在存储器中的加载器来运行它。任何 Unix 程序都可以通过调用`execve`函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器，然后通过跳转到程序的第一条指令或入口点来运行程序。这个将程序拷贝到存储器并运行的过程称为加载。

简单描述一下加载的过程：Unix 系统每个程序都运行于一个进程上下文中，有自己虚拟的地址空间。当 Shell 运行一个程序时，生成一个子进程，子进程通过`execve`系统调用启动加载器。加载器删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。新的堆栈被初始化为 0。然后，将虚拟地址空间中的页映射到可执行文件的页大小的片，新代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到`_start`地址，最终会调用应用程序的`main`函数。

### 动态链接共享库

静态库有着一些明显的缺点，即维护起来相对麻烦，并且当使用非常频繁时会系统资源造成极大浪费。

共享库是致力于解决静态库缺陷的一个现代创新产物。动态链接器可以将共享库加载到任意地址，与程序链接。共享库也称为共享对象（shared object），在 Unix 中通常为`.so`后缀，Windows 大量使用了共享库，称为 DLL。

在任何给定的文件系统中，对于一个库只有一个`.so`文件，所有引用它的程序共享这个文件中的代码和数据。并且，一个共享库的一个副本可以被多个正在运行的不同进程共享。

创建共享库的命令如下：

```shell
$ gcc -shared -fPIC -o libvector.so addvec.c multvec.c
```

创建了共享库后，可以将其与源代码链接：

```shell
$ gcc -o p2 main2.c ./libvector.so
```

这样就创建了一个可执行目标文件`p2`，此文件的形式使得它在运行时可以和`libvector.so`链接。基本思路是当创建可执行文件时，静态执行一些链接，然后程序加载时，动态完成链接过程。这里有一点很重要：**`p2`中没有任何`libvector.so`中的数据节**，链接器只是获取了一部分`libvector.so`中的重定位和符号表信息。

动态链接器通过执行重定位和符号引用完成链接，并最后将控制传递给应用程序。

### 从应用程序中加载和链接共享库

在应用程序运行时，也可以要求动态链接器加载和链接任意共享库，无需在编译时链接到应用中。动态链接是一项强大有用的技术，可以用于很多方面，例如分发软件、构建高性能 Web 服务器等。其思路是将生成动态内容等每个函数打包在共享库中，当一个来自 Web 的请求到达时，服务器加载和链接适当的函数，然后直接调用它，而不是`fork`和`exevce`在子进程的上下文中运行函数。

Unix 提供了一个简单的`dlopen`函数来支持动态链接操作。

### 与位置无关的代码（PIC）

共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码。要使多个进程共享一个拷贝，一种方法就是给每个共享库分配一个专用的地址片，然后要求加载器总是在这个地址加载共享库。这个方法对空间的使用率不高，并且难以管理。另一种更好的方法是编译库代码，使得不需要链接器修改，库代码就可以在任何位置加载和执行。这种代码就称为位置无关代码（PIC）。之前我们用到了 GCC 的`-fPIC`选项，就是指示 GCC 编译出 PIC 代码。

