---
layout: post
title: 操作系统笔记（二）：异常控制流
author: wzhzzmzzy
date: 2018-7-12
categories: Tech
tags: 
    - Linux
    - 操作系统
description: 之前在学习硬件的时候学到了中断，确实是很有意思的一个东西。硬件中断和系统异常非常相似，不过系统异常的使用会更加广泛一些。学习进程不得不了解一下系统的异常控制流，已经信号等等。
---

## 异常控制流

程序需要对程序状态的变化作出反应，所以需要跳转、调用、返回这样的一些程序指令。系统也必须能够对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序执行相关。

现代系统通过控制流突变来对情况作出反应，这种突变称为**异常控制流**。异常控制流发生在系统的各个层次。

### 异常

异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。异常就是控制流的突变，用来响应处理器状态中的某些变化。在处理器中，状态被编码为不同的位和信号，状态变化就称为**事件**。事件可能和当前指令的执行直接相关，也可能无关。

当事件发生时，处理器会通过异常表，进行一次间接过程调用，到异常处理程序当中。

#### 异常处理

系统中可能的每种类型的异常都分配来一个唯一的异常号。异常类似于过程调用，但是有一些重要的不同之处。

- 过程调用时，处理器会先将返回地址压栈，但是根据异常的类型，返回地址要么时当前指令，要么是下一条指令。
- 处理器也把一些额外的处理器状态压栈，如标志位等，重新开始被中断的程序会需要这些状态。
- 如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是用户栈。
- 异常处理程序运行在内核模式下，也就是说它们对所有的系统资源都有完全的访问权限。

一旦硬件触发了异常，剩下的工作由异常处理程序在软件中完成。

#### 异常的类别

异常分为四类：中断、陷阱、故障、终止。

1. **中断**

   中断是异步的，是来自处理器外部的 I/O 设备信号的结果。硬件中断不是由任何一条专门的指令造成的。硬件中断的异常处理程序通常称为中断处理程序。

2. **陷阱和系统调用**

   陷阱是有意的异常，是执行指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。

   用户程序经常需要向内核请求服务，比如`read`、`fork`、`execve`、`exit`等等。为了允许这些对内核服务的访问，处理器提供了`syscall n`指令。执行`syscall`指令会导致一个到异常处理程序的陷阱。从程序猿的角度看，系统调用和普通的函数调用说一样的，然而，实现非常不同。系统调用运行在内核模式中。

3. **故障**

   故障由错误情况引起。能够被故障处理程序修正。一个经典的故障实例是缺页。当发生缺页异常时，我们需要从磁盘中取出缺少的物理页面。

4. **终止**

   终止时不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 RAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。

   
#### Linux/IA32 系统中的异常

IA32 系统定义中，有高达 256 种不同的异常类型。0～31 对应 Intel 架构师定义的异常，32～255 对应操作系统定义的中断和陷阱。

1. **Linux/IA32 故障和终止**

   除法错误、一般保护故障、缺页、机器检查。

2. **Linux/IA32 系统调用**

   Linux 提供上百种系统调用，用于请求内核服务。在 IA32 系统上，系统调用通过`int n`的陷阱命令来提供。在 C 中，我们可以用`syscall`直接调用任何系统调用，但是几乎没必要这么做。对于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些函数称为系统级函数。

   举一个简单的例子，是输出 Hello world 的程序：

   ```c
   int main() {
       write(1, "hello, world\n", 13);
       exit(0);
   }
   ```

   `write`函数的第一个参数是将输出发送到`stdout`，第二个参数是要写的字节序列，第三个参数是要写的字节数。

### 进程

异常时允许操作系统提供进程概念所需要的基本构造块。

进程的经典定义是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文中的。上下文由程序正确运行所需要的状态组成。这个状态包括存放在存储器中的程序的代码和数据它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件 描述符的集合。

每当用户在 Shell 中运行一个程序，Shell 会创建一个新的进程，并在其中运行可执行目标文件。

进程提供给应用程序一些关键的抽象：

- 一个独立的逻辑控制流，提供独占处理器的假象；
- 一个私有的地址空间，提供独占存储器的假象。



#### 逻辑控制流

程序执行时，PC 会有一连串的值，表示一连串控制指令，这个 PC 值的序列就称为逻辑控制流。每个进程都拥有一个逻辑流，三个逻辑流的执行是交错的。进程 A 运行了一会儿，然后 B 开始运行到完成。然后进程 C 运行了一会儿，进程 A 接着运行到完成。

#### 并发流

一个逻辑流的执行在时间上与另一个流重叠，称为**并发流**。多个流并发地执行的一般现象称为**并发**。一个进程和其他进程轮流运行的概念称为**多任务**。一个进程执行它的控制流的一部分的每一时间段叫做**时间片**。

如果两个流并发地运行于不同的处理器核或者计算机上，那么称为**并行流**。

#### 私有地址空间

进程拥有它的私有地址空间，和这个空间相关联的存储器上不能被其他进程读写的。每个私有地址空间有着相同的通用结构。

#### 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程假象，处理器必须提供一种机制，限制一个应用可以执行的指令以及可以访问的地址空间范围。处理器通过模式位来进行区分，模式位描述了进程当前想有的特权。

设置模式位后，进程就运行在内核模式中，可以执行指令集的任何指令，访问存储器的任何位置。没有设置模式位时，进程就运行在用户模式中，用户模式中的进程不允许执行特权指令。

应用程序的进程初始时是在用户模式中的，进程从用户模式变为内核模式的唯一方法是通过异常。

#### 上下文切换

内核使用上下文切换来实现多任务。

内核为每一个进程维持上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个之前被抢占的进程。这就叫做调度，由调度器管理。当内核选择一个新的进程运行时，就说调度了这个进程。

上下文切换的步骤：1) 保存当前进程的上下文， 2) 恢复某个先前被抢占的进程被保存的上下文， 3) 将控制传递给这个新恢复的进程。 

一般而言，硬件高速缓存存储器不能和诸如中断和上下文切换这样的异常控制流很好地交互。 如果当前进程被一个中断暂时中断，那么对于中断处理程序来说高速缓存是冷的。 如果处理程序从 主存中访问了足够多的表项，那么当被中断的进程继续时，高速缓存对它来说也是冷的了。在这种情况下，我们就说中断处理程序污染了高速缓存。 

### 系统调用错误处理

当 Unix 系统级函数遇到错误时，它们典型地会返回`-1`, 并设置全局整数变量`errno`来表示什么出错了。错误检查十分重要，但是会让代码变得臃肿。

举个例子，一个简单的 Unix Fork 错误检查：

```c
if (pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(0);
}
```

这个流程很简单，`fprintf`函数将一些简单的错误信息发送到`stderr`管道中。但是其实可以包装一下。

```c
void unix_error(char *msg) {
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork(void) {
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
```

这样的话，我们要`Fork`时，操作就只有一行了：

```c
pid = Fork();
```

### 进程控制

#### 获取进程ID

每个进程都有一个 PID，`getpid`函数返回调用它的进程的 PID。`getppid`函数返回它的父进程的 PID。

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

#### 创建和终止进程

进程总是在下面三种状态之一：运行、挂起、终止。

父进程通过`fork`来创建一个新的子进程。新创建的子进程几乎但不完全与父进程相同。子进程的到与父进程用户级虚拟地址空间相同但是独立的一份拷贝。子进程还获得与父进程 任何打开文件描述符相同的拷贝，这就意味着当父进程调用`fork`时，子进程可以读写父进程中打开的任何文件。 

`fork`函数调用一次，返回两次，父进程中，`fork`返回子进程的 PID。在子进程中， fork 返回 0。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。下面是一个简单的例子：

```c
#include "csapp.h"

int main() {
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0) {
        printf("child: x=%d\n", ++x);
        exit(0);
    }
    
    printf("parent: x=%d\n", --x);
    exit(0);
}
```

总结一下`fork`的特性：**调用一次，返回两次**、**并发执行**、**相同但是独立的地址空间**、**共享文件**。

#### 回收子进程

当进程终止时，会保持在终止状态一段时间，直到被父进程回收。内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程。终止还未回收的进程称为僵死进程。

如果父进程没有回收子进程就终止了，内核会安排`init`来回收它们。

一个进程可以调用`waitpid`来等待子进程终止或者停止。

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
// 如果成功，返回子进程的 PID，如果 WHOHANG，返回 0，如果其他错误，返回 -1
```

`waitpid`有点复杂，当`options=0`时，它挂起调用进程，直到等待集合中一个子进程终止。如果刚调用就终止了，那么`waitpid`就立即返回。

1. **判定等待集合的成员**

等待集合的成员由参数`pid`来确定：如果`pid>0`，那么等待集合就是一个`pid`指向的单独的子进程；如果`pid=-1`那么等待集合就由父进程所有的子进程组成。

2. **修改默认行为**

可以将`options`设置为常量`WHOHANG`和`WUNTRACED`的各种组合，修改默认行为：

- `WHOHANG`：不等待，如果子进程未终止，直接返回 0；
- `WUNTRACED`：挂起，直到子进程终止，返回终止的子进程的 PID；
- `WHOHANG|WUNTRACED`：立即返回，返回值视情况而定。

3. **检查已经回收的子进程的退出状态**

如果`status`参数非空，`waitpid`就会在`status`参数中放上返回的子进程的状态信息。

4. **错误条件**

如果调用进程没有子进程，或者被信号中断，那么`waitpid`返回`-1`。

5. **`wait`函数**

`wait`是`waitpid`的简单版本，`wait(&status)`等价于`waitpid(-1, &status, 0)`。

有一个`waitpid`的示例：

```c
#include "csapp.h"
#define N 2

int main() {
    int status, i;
    pid_t pid[N], retpid;
    
    for (i = 0; i < N; ++i) {
        if ((pid[i] = Fork()) == 0)
            exit(100+i);
    }
    i = 0;
    while ((retpid = waitpid(pid[i++], &status, 0)) > 0) {
        if (WIFEXITED(status))
            printf("child %d terminated normally with exit status=%d\n", retpid, WEXITSTATUS(status));
        else
            printf("child %d terminated abnormally\n", retpid);
    }
    
    if (errno != ECHILD)
        unix_error("waitpid error");
    
    exit(0);
}
```

#### 让进程休眠

`sleep`函数将进程挂起一段时间。`pause`函数让调用函数休眠，直到收到一个信号。

#### 加载并运行程序

`execve`函数在进程的上下文中加载并运行一个程序。

```c
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
```

`execve`函数加载并运行可执行目标文件，以及参数列表和环境变量列表。只有当出现错误的时候，才返回到调用程序。`execve`函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当 前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的 PID, 并且继承了调用`execve`函数时已打开的所有文件描述符。 

### 信号

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。 

#### 信号术语

传送信号由两个不同的步骤组成：发送信号、接收信号。

一个只发出而没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。 一个进程可以有选择性地阻塞接收某种信号。当一 种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

#### 发送信号

Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组这个概念的。 

每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。 `getpgrp`函数返回进程组 ID。默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用`setpgid`函数来改变自己或者其他进程的进程组。

```c
#include <unistd.h>

pid_t getpgrp(void);
pid_t setpgid(pid_t pid, pid_t pgid);
// setpgid 将 pid 的进程组改为 pgid。pid=0 表示当前进程的 PID，pgid=0 表示当前进程的进程组。
// setpgid(0, 0) 会创建一个新的进程组。
```

`/bin/kill`用于发送信号。

```shell
$ /bin/kill -9 15213   # 发给进程
$ /bin/kill -9 -15213  # 发给进程组
```

C 语言中也有`kill`函数，用于发送信号。

#### 接收信号

当内核从一个异常处理程序返回，准备将控制传递给进程`p`时，会检查进程`p`的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到`p`到逻辑控制流的下一条指令。

如果集合非空，内核选择最小的信号，强制`p`接收。进程可以注册信号处理器来捕获和处理信号。

信号处理程序是计算机系统中并发的又一个示例。信号处理程序的执行中断 `main`函数的执行，类似于低层异常处理程序中断当前应用程序的控制流的方式。因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和主函数并发地运行。  
