---
layout: post
title: Python 科学计算 —— NumPy
author: wzhzzmzzy
date: 2017-09-08
updated: 2017-9-14
categories: Tech
tags: [Python]
description: NumPy是Python2的一个库。用到了IPython，但是因为macOS的Py2先天权限管理的问题，没办法用PyPi来安装，所以就放弃了。NumPy里面有很多有用的函数，数组也十分强大，但是要注意的是时间上的损耗很惊人，比Py内置的函数慢了很多，而Py本来就已经很慢了。
---

### NumPy

```python
import numpy as npv
np.__version__ # 版本号
```

#### nbarray 对象

NumPy中用`ndarray`表示数组，是整个库的核心对象，NumPy中所有函数都是围绕`ndarray`对象进行处理的。`ndarray`的结构并不复杂，但是功能十分强大。不但可以用它高效地存储大量的数值元素，从而提高数值计算的运算速度，还能用它与各种扩展库进行数值交换。

##### 创建

创建数组很简单。

```python
a = np.array([1,2,3,4])
b = np.array([[1,2,3,4],[5,6,7,8]])
```

数组的形状可以由`shape`属性获得，是一个描述数组各个轴长度的元组。可以通过修改`shape`属性值来对数组进行重新划分。

```python
a.shape # (4,)
b.shape # (2, 4)

a.shape = 2, 2 # a array([[1,2],[3,4]])
b.shape = 4, -1 # b array([[1,2],[3,4],[5,6],[7,8]])
```

可以使用数组的`reshape()`方法，来根据原数组创建新数组。

##### 元素类型

数组的元素类型可以通过`dtype`属性获得。在前面的例子中，创建数组所用的序列的元素都是整数，因此所创建的数组的元素类型是整形，并且是32位的长整型。`dtype.type`可以获取`type`类型的对象。

```python
a.dtype # dtype('int64')
a.dtype.type # <type 'numpy.int64'>
```

可以通过`dtype`参数在创建数组时指定元素类型，注意`float`类型是64位的双精度浮点类型，而`complex`是128位的双精度复数类型，`np.int32`则是NumPy`定义的新的数据类型——32位符号整数类型：

```python
ai32 = np.array([1,2,3,4], dtype=np.int32)
af = np.array([1,2,3,4], dtype=float)
ac = np.array([1,2,3,4], dtype=complex)
```

NumPy也有自己的浮点数类型：`float16`，`float32`，`float64`，`float128`。当使用`float64`作为`dtype`参数时，效果和内置的`float`类型相同。

每种元素数值类型都有几种不同的字符串表达方式，字符串和类型之间的对应关系都存储在`typeDict`字典中，可以通过下面的命令获得对应的所有键值：

```python
[key for key, value in np.typeDict.items() if value is np.float64]
# [12, 'd', 'float64', 'float_', 'float', 'f8', 'double', 'Float64']
```

完整的类型列表可以通过下面的语句得到，它将`typeDict`字典中的所有制转换为一个集合，从而去除其中的重复项。

```python
set(np.typeDict.values())
```

通过NumPy的数值类型也可以创建数值对象，下面创建一个16位的符号整数对象，它与Python的整数对象不同的是，它的范围有限，因此计算`200*200`会溢出，得到一个负数，这一点与C语言的16位整数相同。

另外值得注意的是，NumPy的数值对象的运算速度比Python内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应当尽量避免使用NumPy的数值对象。下面的命令比较了两者的运算速度：

```python
u = 3.14
v = np.float64(u)
%timeit u*u
%timeit v*v
```

使用`astype()`方法可以对数组的元素类型进行转换，下面将浮点数数组`t1`转换为32为整数数组，将双精度的复数数组`t2`转换为单精度的复数数组：

```python
t1 = np.array([1,2,3,4], dtype=np.float)
t2 = np.array([1,2,3,4], dtype=np.complex)
t3 = t1.astype(np.int32)
t4 = t2.astype(np.complex64)
```

##### 自动生成数组

前面的例子都是先创建一个Python的序列对象，然后通过`np.array()`将其转换为数组，这样做显然效率不高。因此NumPy提供了很多专门用于创建数组的函数。下面每一个函数都有一些关键字参数，具体用法参看函数说明。

`arange()`类似于内置函数`range()`，通过制定开始值、终值和步长来创建表示等差数列的一维数组，注意所得到的结果不包含终值。例如下面的程序创建开始值为0，终值为1，步长为0.1的等差数组，注意终值1不在数组中。

```python
np.arange(0, 1, 0.1)
# array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
```

`linspace()`通过制定初值、终值和元素个数来创建表示等差数列的一维数组。可以通过`endpoint`参数制定是否包含终值，默认值为`True`，即包含终值。

```python
np.linspace(0, 1, 10) # 步长 1/9
np.linspace(0, 1, 10, endpoint=False) # 步长 1/10
```

`logspace()`和`linspace()`类似，不过它所创建的数组是等比数列。下面的例子产生从 $10^0$ 到 $10^2$，有5个元素的等比数列，注意起始值0代表 $10^0$，而终值2表示 $10^2$：

```python
np.logspace(0, 2, 5)
# [1. , 3.16227766, 10. , 31.6227766 , 100. ]
```

基数可以通过`base`参数确定，其默认值为10。下面通过将`base`参数设置为2，并设置`endpoint`参数为`False`，创建一个比例为 $2^{frac{1}{12}}$ 的等比数组，此等比数组的比值啥音乐中相差半音的两个音阶之间的频率比值，因此可以用它计算一个八度中所有半音的频率：

```python
np.logspace(0, 1, 12, base=2, endpoint=False)
# [ 1.          1.05946309  1.12246205  1.18920712  1.25992105  1.33483985 1.41421356  1.49830708  1.58740105  1.68179283  1.78179744  1.88774863]
```

`zeros()`、`ones()`、`empty()`可以创建指定形状和类型的数组。其中`empty()`只分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。下面的程序创建一个形状为`(2, 3)`、元素类型为整数的数组，注意其中的元素值没有被初始化：

而`zeros()`将数组元素初始化为0，`ones()`将数组元素初始化为1。下面创建一个长度为4，元素类型为整数的一位数组，并且元素全部初始化为0。

```python
np.empty((2,3), np.int)
np.zeros(4, np.int)
np.full(4, np.pi) # 初始化为指定的值
```

此外，`zeros_like()`、`ones_like()`、`empty_like()`、`full_like()`等函数创建与参数数组的形状与类型相同的数组，因此`zeros_like(a)`和`zeros(a.shape, a.dtype)`的效果相同。

`frombuffer()`、`fromstring()`、`fromfile()`等函数可以从字节序列或文件创建数组。下面以`fromstring()`为例介绍它们的用法，先创建8个字符的字符串`s`，Python的字符串实际上是一个字节序列，每个字符占一个字节。因此如果从字符串`s`创建一个8为整数数组，所得到的数组是字符串的ASCII编码。

```python
s = "abcedfg"
np.fromstring(s, dtype=np.int8)
```

如果从字符串`s`创建一个16位整数数组，那么两个相邻的字节就表示一个整数，吧字节98和字节97当作一个16位的整数，他的值就是 $98\times 256+97=25185$。可以看出，16位的整数啥以低位字节在前的方式保存在内存中的。

```python
np.fromstring(s, dtype=np.int16)
# array([25185, 25699, 26213, 26727], dtype=int16)
```

如果把整个字符串转化为一个64位的双精度浮点数数组，那么它的值是：

```python
np.fromstring(s, dtype=np.float)
# array([8.54088322e+194])
```

显然这个结果没有什么意义，但是如果我们用C语言的二进制方式写了一组`double`类型的数值到某个文件中，那就可以从此文件读取相应的数据，并通过`fromstring()`将其转换为`float64`类型的数组，或者直接使用`fromfile()`从二进制文件读取数据。

`fromstring()`会对字符串的字节序列进行复制，而使用`frombuffer()`创建的数组与原始字符串共享内存。由于字符串是只读的，因此无法修改所创建的数组的内容：

```python
buf = np.frombutter(s, dtype=np.int16)
buf[1] = 10 # ValueError
```

Python中还有一些类型也支持`buffer`接口，例如`bytearray`、`array.array`等。在后面的章节中，我们会介绍如何使用这些对象实现动态数组功能。

还可以先定义一个从下标计算数值的函数，然后用`fromfunction()`通过此函数创建数组：

```python
func = lambda i: i%4+1
np.fromfunction(func, (10,))
# [1., 2., 3., 4., 1., 2., 3., 4., 1., 2.]
func = lambda i,j: (i+1)*(j+1)
np.fromfunction(func2, (9,9)) # 九九乘法表
# [[  1.   2.   3.   4.   5.   6.   7.   8.   9.]
# [  2.   4.   6.   8.  10.  12.  14.  16.  18.]
# [  3.   6.   9.  12.  15.  18.  21.  24.  27.]
# [  4.   8.  12.  16.  20.  24.  28.  32.  36.]
# [  5.  10.  15.  20.  25.  30.  35.  40.  45.]
# [  6.  12.  18.  24.  30.  36.  42.  48.  54.]
# [  7.  14.  21.  28.  35.  42.  49.  56.  63.]
# [  8.  16.  24.  32.  40.  48.  56.  64.  72.]
# [  9.  18.  27.  36.  45.  54.  63.  72.  81.]]
```

#### 存取元素

可以使用和列表相同的方式对数组的元素进行存取：

```python
a = np.arange(10)
a[5] # 5
a[3:5] # [3, 4]
a[:5] # [0, 1, 2, 3, 4]
a[:-1] # [0, 1, 2, 3, 4, 5, 6, 7, 8]
a[1:-1:2] # [1, 3, 5, 7]
a[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
a[5:1:-2] # [5, 3]
```

和列表不同的是，通过切片获取的新数组的原始数组的一个试图。它与原始数组共享一块数据存储空间。下面的程序将`b`的第二个元素修改为-10，`a`的第5个元素也同时被修改为-10，因此它们在内存中的地址相同。

除了使用切片下标存取元素之外，NumPy还提供了整数列表、整数数组和布尔数组等几种高级下标存取方法。

当使用整数列表对数组元素进行存取时，将使用列表中的每个元素作为下标。使用列表作为下标得到的数组不和原始数组共享内存，整数序列下标也可以用来修改元素的值：

```python
x = np.arange(10, 1, -1)
a = x[[3, 3, 1, 8]]
b = x[[3, 3, -3, 8]]
x[[3, 5, 1]] = -1, -2, -3
```

**当使用整数数组作为数组下标时，将会得到一个形状和下标数组相同的新数组**，新数组的每一个元素都是用下标数组中对应位置的值作为下标从原数组获得的值。当下标数组是一维数组时，结果和用列表作为下标的结果是一样的，而多维数组时，得到的也是多维数组：

```python
x = np.aragne(10,1,-1)
x[np.array([3,3,1,8])]
x[np.array([[3,3,1,8],[3,3,-1,8]])]
x[[3,3,1,8,3,3,-1,8]].reshape(2,4) # 和上一句等同
```

当使用布尔数组`b`作为下标存取数组`x`中的元素时，将获得数组`x`中与数组`b`中`True`对应的元素。使用布尔数组作为下标获得的数组不和原始数组共享数据内存，注意这种方式只对应于布尔数组，不能使用布尔列表。

```python
x[np.array([True, False, True, False, False])]
x[np.array([True, False, True])] # 等同
```

布尔数组一般不是手工产生，而是使用布尔运算的`ufunc`函数产生，关于`ufunc`函数请参照下一节的介绍。下面我们举一些简单的例子说明布尔数组下标的用法：

```python
x = np.random.randint(0, 10, 6) # 产生一个长度为6，元素值为0到9的随机整数数组
x[x>5] # 生成一个布尔数组，收集x中所有大于5的数
```

#### 多维数组

多维数组的存取和一维数组类似，因为多维数组有多个轴，所以它的下标需要用多个值来表示。NumPy采用元组作为数组的下标，元祖中的每个元素和数组的每个轴对应。

> 为什么用元组作为下标？Python的下标语法本身不支持多维，但可以使用任何对象作为下标，因此，NumPy使用元组作为下标存取数组中的元素，使用元组可以很方便地表示多个轴的下标。虽然在Python程序中经常用圆括号将元组的元素括起来，但是事实上元组的语法只需要用逗号隔开元素即可，例如，`x,y=y,x`就是用元组交换变量值的一个例子。因此，`a[1,2]`和`a[(1,2)]`完全相同，都是使用元组`(1,2)`作为数组`a`的下标。

可以通过`arange`相加可以获取需要的二维数组，这样构成的数组，第0个元素与数组的纵轴对应，而第1个元素和横轴对应：

```python
a = np.arange(0, 60, 10).reshape(-1, 1) + np.aragne(0, 6)
a[0] # [0 1 2 3 4 5]
a[1] # [10 11 12 13 14 15]
a[:, 2] # [2 12 22 32 42 52]
a[2::2, ::2] # [[20 22 24] [40 42 44]]
```

如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图。下面的例子中，数组`b`是`a`的视图，它们共享数据，因此修改`b[0]`时，数组`a`中对应的元素也被修改。

```python
b = a[0, 3:5]
b[0] = -b[0]
a[0, 3:5]
# array([-3, 4])
```

因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组。在下面的例子中，`a[idx]`和`a[::2,2:]`相同，`a[idx][idx]`和`a[::2,2:][::2,2:]`。

```python
idx = slice(None, None, 2), slice(2, None)
```

> 切片对象。根据Python的语法，在[]中可以使用以冒号隔开的两个或三个整数表示切片，但是单独生成切片对象时需要使用`slice()`来创建。它由三个参数，分别为开始值、终值和步长，当这些值需要省略时可以使用`None`。

用Python的内置函数`slice()`创建下标比较麻烦，因此NumPy提供一个`s_`对象来帮助我们创建数组下标，请注意`s_`实际上是`IndexExpression`类的一个对象：

```python
np.s_[::2, 2:]
# (slice(None, None, 2), slice(2, None, None))
```

> s_为什么不是函数？根据Python的语法，只有在中括号[]中才能使用以冒号隔开的切片语法，如果`s_`是函数，那么这些切片必须使用`slice()`创建。类似的对象还有`mgrid`和`ogrid`等，后面我们会学习它们的用法。Python的下标语法实际上会调用`__getitem__()`方法，因此我们可以很容易自己实现`s_`对象的功能：

```python
class S(object):
    def __getitem__(self, index):
        return index
```

在多维数组的下标元组中，也可以使用整数元祖或列表、整数数组和布尔数组。当下标使用这些对象时，所获得的数字是原始数据的副本，因此修改结果数组不会改变原始数组。

#### 结构数组

在C语言中我们可以通过`struct`关键字定义结构类型，结构中的字段占据连续的内存空间。类型相同的两个结构所占用的内存大小相同，因此可以很容易定义结构数组。和C语言一样，在NumPy中也很容易对这种结构数组进行操作。只要NumPy中的结构定义和C语言中的结构定义相同，就可以很方便地读取C语言的结构数组的二进制数据，将其转换为NumPy的结构数组。

假设我们需要定义一个结构数组，它的每个元素都有`name`、`age`和`weight`字段。在NumPy中可以如下定义：

```python
persontype = np.dtype({
    'names':['name', 'age', 'weight'],
    'formats':['S30', 'i', 'f']}, align=True)
a = np.array([("Zhang", 32, 75.5), ("Wang", 24, 65.2)], dtype=persontype)
```

我们先创建一个`dtype`对象`persontype`，它的参数是一个描述结构类型的各个字段的字典，字典有两个键：`'names'`和`'formats'`。每个键对应的值都是一个列表。`'names'`定义结构中每个字段的名称，而`'formats'`则定义每个字段的类型。这里我们使用类型字符串定义字段类型。

* `'S30'`: 长度为30字节的字符串类型，由于结构中每个元素大小必须固定，因此需要制定字符串的长度。
* `'i'`：32位整数，相当于`np.int32`。
* `'f'`：32位单精度浮点数类型，相当于`np.float32`。

然后我们调用`array()`以创建数组，通过`dtype`参数指定所创建的数组的元素类型为`persontype`。下面查看数组`a`的元素类型：

```python
a.dtype
# dtype({'names':['name','age','weight'], 'formats':['S30','<i4','<f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True})
```

还可以用包含多个元组的列表来描述结构的类型：

```python
dtype([('name', '|S30'), ('age', '<i4'), ('weight', '<f4')])
```

其中形如“（字段名，类型描述）”的元组描述了结构中的每个字段。类型字符串前面的`'I'`、`'<'`、`'>'`等字符表示字段值的字节顺序：

* `'I'`：忽视字节顺序。
* `'<'`：低位字节在前，即小端模式。
* `'>'`：高位字节在前，即大端模式。

结构数组的存取方式和一般数组相同，通过下标能够取得其中的元素，注意元素的值看上去像是数组，实际上是结构：

```python
print a[0]
a[0].dtype
# ('Zhang', 32, 75.5)
# dtype({'names':['name','age','weight'], 'formats':['S30','<i4','<f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True})
```

我们可以使用字段名作为下标获取对应的字段值：

```python
a[0]['name']
# 'Zhang'
```

`a[0]`是一个结构元素，它和数组`a`共享内存，因此可以通过修改它的字段改变原始数组中对应元素的字段。我们不但可以获得结构元素的某个字段，而且可以直接获得结构数组的字段，返回的是原始数组的视图，因此可以通过修改`b[0]`来改变`a[0]['age']`。

通过`a.tostring()`或`a.tofile()`方法，可以将数组`a`以二进制的方式转换成字符串或者写入文件：

```python
a.tofile('test.bin')
```

利用下面的C语言程序可以将`test.bin`文件中的数据读取出来。
vc
```c++
struct person {
    char name[30];
    int age;
    float weight;
} p[3];

int main() {
    FILE *fp = fopen("test.bin", "rb");
    fread(p, sizeof person, 2, fp);
    fclose(fp);
    for(int i = 0; i < 2; ++i)
        printf("%s %d %f\n", p[i].name, p[i].age, p[i].weight);
}
```

### `ufunc`函数

`ufunc`相当于Python的`map`，能对数组的每一个元素执行运算。区别在于返回了一个新数组，并没有改变原数组的值。也可以通过`out`参数来指定保存计算结果的数组。另一个区别是NumPy的这些`ufunc`函数都是用C语言实现的，所以比Py2自带的函数用`map`去实现这样的功能要快十倍以上。

这些函数也支持单个数值的运算，但是在单个数值时会比`math`库中的函数慢很多。此外，对于单个数值的计算，`np.sin()`和`math.sin`返回值类型不同，`NumPy`的返回值是`float64`类型。通过下标运算获取的数组元素的类型为NumPy中定义的类型，将其转换为Python的标准类型还需要花费额外的事件。数组提供了`item()`方法来解决这个问题，用来获取数组中的单个元素，并且直接返回为标准的Python数据类型。

```python
x = np.linspace(0, 2*np.pi, 10)
y = np.sin(x, out = x)
y is x # True
```

#### 四则运算、比较运算和布尔运算

NumPy提供了很多`ufunc`函数，比如计算两个数组之和的`add()`函数，还有`subtract`，`multiply`等等。

使用`==`、`>`等比较运算符对两个数组进行比较，将返回一个布尔数组，它的每个元素值都是两个数组对应元素的比较结果。由于Python中布尔运算使用`and`、`or`、`not`等关键字，无法被重载，因此数组的布尔运算只能通过相应的`ufunc`函数进行。这些函数名以`logical_`开头。

```python
np.logical_or(a==b, a>b) # 等同于 a >= b
```

可以使用数组的`any()`和`all()`函数，和Python内置的函数相同。

`bitwise_`开头的是位运算函数。对于布尔数组来说，位运算和布尔运算结果相同，但是使用时位运算的优先级高于布尔运算。整数位运算和C语言位运算相同，注意元素类型的符号。

#### 自定义`ufunc`函数

通过NumPy提供的标准`ufunc`函数，可以组合出复杂的表达式，在C语言级别对数组的每个元素进行计算。但是有时候这种表达式不易编写，而对每个元素进行计算的程序却很容易用Python实现，这是可以用`frompyfunc()`将计算单个元素的函数转换成`ufunc`函数，这样就可以方便地用所产生的`ufunc`函数对数组进行计算了。

下面是一个计算三角波上某点的Y坐标的函数。

```python
def triangle_wave(x, c, c0, hc):
    x = x - int(x)
    if x >= c: r = 0.0
    elif x < c0: r = x / c0 * hc
    else: r = (c-x) / (c-c0) * hc
    return r
```

通过`frompyfunc()`可以将计算单个值的函数转换为能对数组的每个元素进行计算的`ufunc`函数。值得注意的是，转化之后的函数返回值类型是`object`，需要用`astype`方法把它转化为双精度浮点数组。

```python
frompyfunc(func, nin, nout) # 函数 传参个数 返回值个数
trignle_wave_ufunc = np.frompyfunc(triagnle_wave, 4, 1)
```

#### 广播

当使用`ufunc`函数对两个数组进行计算时，`ufunc`函数会对这两个数组的对应元素进行计算，因此它要求这两个数组的形状相同。如果形状不同，会进行如下广播处理：

- 让所有输入数组都向维数最多的数组看起，不足部分通过加1补齐。
- 输出数组的`shape`属性是输入数组的`shape`属性的各个轴上的最大值。
- 如果输入数组的某个轴的长为1或与输出数组的对应轴长度相同，这个数组就能够用来计算，否则会报错。
- 当输入数组的某个轴长度为1时，沿着此轴运算时，都用此轴的第一组值。